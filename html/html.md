#### 1. Для чего нужен doctype?

**Ответ:**

Согласно спецификациям HTML и XHTML тег DOCTYPE сообщает валидатору, какую именно версию (X)HTML вы используете в своей странице. Этот тег должен всегда находиться в первой строке каждой страницы. Что бы сообщить браузеру, что мы используем тип документа HTML 5, надо указывать `<!DOCTYPE html>`

##### Источники:

- [Спецификация](https://html.spec.whatwg.org/multipage/syntax.html#the-doctype)
- [Дока](https://doka.guide/html/doctype/)
- [MDN](https://developer.mozilla.org/en-US/docs/Glossary/Doctype)

---

#### 2. Что такое режим совместимости (Quirks Mode) и стандартный режим (Standards Mode)?

**Ответ:**

Режим совместимости (Quirks Mode) и стандартный режим (Standards Mode) - это два различных режима отображения страниц в браузерах, которые определяют, как именно будут интерпретироваться HTML и CSS.

`Режим совместимости (Quirks Mode):`

- Этот режим был введен для того, чтобы браузеры корректно отображали старые веб-страницы, которые были разработаны до того, как стандарты веб-разработки были четко определены.
- В этом режиме браузеры имитируют старое, некорректное поведение (например, управление box model, когда ширина блока включала в себя padding и border), чтобы старые сайты не выглядели сломанными.
- Пример: Если страница не содержит правильный DOCTYPE (или вообще его не содержит), браузер переключится в режим совместимости.

`Стандартный режим (Standards Mode):`

- Это режим, в котором браузеры строго следуют современным стандартам HTML, CSS и другим веб-технологиям, установленным W3C и другими организациями.
- В этом режиме браузеры отображают страницы в соответствии с последними стандартами, что обеспечивает корректное и предсказуемое поведение веб-страниц.
- Пример: Если на странице правильно указан DOCTYPE, браузер включит стандартный режим, и CSS будет применяться в соответствии с современными стандартами.

Кроме того, существует промежуточный режим, который иногда называют `"Almost Standards Mode"`. В этом режиме браузеры следуют стандартам, но с некоторыми исключениями, например, в отношении обработки изображений внутри таблиц.

##### Источники:

- [MDN](https://developer.mozilla.org/ru/docs/Web/HTML/Quirks_Mode_and_Standards_Mode)

---

#### 3. В чем разница между HTML и XHTML?

**Ответ:**

`HTML` (HyperText Markup Language) и `XHTML` (eXtensible HyperText Markup Language) – это два языка разметки, которые используются для создания веб-страниц. Основное различие между ними заключается в их синтаксических правилах и степени строгости.

1. `HTML`:

- `Гибкость синтаксиса`: HTML менее строгий с точки зрения синтаксиса. Например, в HTML можно не закрывать некоторые теги (например, `<br>` или `<img>`), и это не вызовет ошибок. Также можно использовать теги и атрибуты без кавычек или даже без завершающих символов.
- `Основан на SGML`: HTML исторически основан на стандарте SGML (Standard Generalized Markup Language), но браузеры часто интерпретируют HTML с различными допущениями и ошибками.
- `Популярное использование`: HTML долгое время оставался стандартом де-факто в веб-разработке благодаря своей простоте и широкому распространению.

2. `XHTML`:

`Строгий синтаксис`: XHTML – это более строгая версия HTML, основанная на стандарте XML (eXtensible Markup Language). Это значит, что каждый тег в XHTML должен быть правильно закрыт (например, `<br />` вместо `<br>`), атрибуты должны быть заключены в кавычки, а теги должны быть правильно вложены.
`Совместимость с XML`: Поскольку XHTML следует правилам XML, его легче обрабатывать с помощью XML-парсеров, что делает его более подходящим для использования в приложениях, где требуется строгий синтаксический контроль.
`Строгая структура документа`: В XHTML необходимо соблюдать правильную структуру документа (например, все теги должны быть в нижнем регистре).

3. `Совместимость и практика`:

`Поддержка браузеров`: Современные браузеры поддерживают как HTML, так и XHTML. Однако, на практике большинство веб-разработчиков предпочитают использовать HTML5, который сочетает в себе гибкость HTML и некоторые строгие аспекты XHTML, но при этом остается более прощающим к синтаксическим ошибкам.
`Стандарты на сегодняшний день`: XHTML не получил столь широкого распространения, как ожидалось, из-за своей строгой природы. В результате, с развитием HTML5, многие стандарты и лучшие практики из XHTML были интегрированы в HTML5, делая его основным выбором для современной веб-разработки.

##### Источники: 

- [MDN](https://developer.mozilla.org/ru/docs/Glossary/XHTML)

---

#### 4. Какая связь между SGML, HTML, XML и XHTML?

**Ответ:**

`SGML` (Standard Generalized Markup Language), `HTML` (HyperText Markup Language), `XML` (eXtensible Markup Language), и `XHTML` (eXtensible HyperText Markup Language) связаны друг с другом через общие принципы и наследование стандартов разметки документов.

1. `SGML`:

- `Основа`: SGML – это основной стандарт, который лежит в основе как HTML, так и XML. Он был разработан для создания описания структуры документов с возможностью использования различных разметок для представления данных.
- `Гибкость`: SGML очень гибок, но его сложность сделала его менее удобным для повседневного использования в веб-разработке. Поэтому на его основе были созданы более простые и специализированные языки разметки, такие как HTML и XML.

2. `HTML`:

- `Производный от SGML`: HTML изначально был создан как упрощённая версия SGML, специально для разметки гипертекстовых документов в Интернете. Он предоставляет набор тегов для разметки текста, ссылок, изображений и других элементов веб-страниц.
- `Гибкость и распространенность`: HTML широко использовался благодаря своей простоте, но он не всегда строго следовал правилам SGML, что приводило к различиям в рендеринге веб-страниц в разных браузерах.

3. `XML`:

- `Производный от SGML`: XML был разработан как более строгая и простая версия SGML, с целью универсальной передачи данных. В отличие от HTML, XML не определяет конкретные теги для разметки, а позволяет разработчикам создавать свои собственные теги для описания структуры данных.
- `Формат данных`: XML широко используется для обмена данными между различными системами и приложениями благодаря своей строгости и универсальности.

4. `XHTML`:

- `Комбинация HTML и XML`: XHTML – это HTML, но оформленный в соответствии с правилами XML. Он использует ту же структуру и теги, что и HTML, но с более строгими синтаксическими правилами, характерными для XML (например, все теги должны быть закрыты, атрибуты должны быть в кавычках и т.д.).
- `Цель`: XHTML был разработан как шаг к стандартизации веб-разметки и обеспечения более строгого контроля над синтаксисом, что делает его более совместимым с XML-парсерами.

Связь между этими технологиями заключается в том, что SGML является прародителем как HTML, так и XML, а XHTML объединяет идеи HTML и XML, чтобы обеспечить строгую разметку веб-страниц.

##### Источники:

- [Wiki SGML](https://ru.wikipedia.org/wiki/SGML)
- [MDN HTML](https://developer.mozilla.org/ru/docs/Web/HTML)
- [MDN XML](https://developer.mozilla.org/en-US/docs/Web/XML/XML_introduction)
- [MDN XHTML](https://developer.mozilla.org/en-US/docs/Glossary/XHTML)

---

#### 5. В чем отличия HTML5 от HTML4.01 и XHTML1.0?

**Ответ:**

HTML5, HTML4.01 и XHTML1.0 – это разные версии языков разметки, которые эволюционировали с течением времени, чтобы адаптироваться к потребностям веб-разработки.

1. `HTML4.01`:

- `Дата выпуска`: HTML4.01 был принят в 1999 году и стал важным шагом в стандартизации веб-контента.
- `Структура и теги`: HTML4.01 представил улучшенные механизмы для работы с таблицами, формами и скриптами, но его структура была ограничена по сравнению с современными стандартами.
- `Разделение содержимого и оформления`: В HTML4.01 начали более активно внедрять концепцию отделения содержимого (HTML) от оформления (CSS), чтобы улучшить поддержку разных устройств.
- `DOCTYPE`: HTML4.01 требует сложного DOCTYPE, который указывает на один из трех режимов: strict, transitional, или frameset.

2. `XHTML1.0`:

- `Дата выпуска`: XHTML1.0 был принят в 2000 году как более строгая версия HTML4.01, основанная на правилах XML.
- `Строгий синтаксис`: В XHTML1.0 каждый тег должен быть закрыт, атрибуты должны быть в кавычках, а теги – в нижнем регистре. Это было сделано для улучшения совместимости с XML-парсерами.
- `Меньшая гибкость`: Из-за своей строгой природы XHTML1.0 требовал точного соблюдения синтаксиса, что усложняло разработку по сравнению с HTML4.01.
- `Цель`: XHTML1.0 был создан для того, чтобы веб-разметка стала более стандартизированной и структурированной, но из-за своей строгой природы он не получил широкого распространения.

3. `HTML5`:

- `Дата выпуска`: HTML5 был официально представлен в 2014 году и представляет собой значительное обновление по сравнению с HTML4.01 и XHTML1.0.
- `Новые семантические теги`: HTML5 ввел множество новых семантических тегов, таких как `<header>`, `<footer>`, `<article>`, `<section>`, что улучшило структуру и доступность веб-страниц.
- `Мультимедийная поддержка`: HTML5 включает встроенную поддержку мультимедийных элементов, таких как `<audio>` и `<video>`, что позволяет использовать медиа без необходимости в плагинах, таких как Flash.
API и возможности: HTML5 представил множество новых API, таких как API для работы с геолокацией, локальным хранилищем (local storage), канвасом для рисования (canvas) и WebSockets для двусторонней связи.
- `Упрощенный DOCTYPE`: HTML5 упростил DOCTYPE до одной строки: `<!DOCTYPE html>`, что устранило необходимость в сложных указаниях.
- `Меньшая строгость синтаксиса`: В отличие от XHTML1.0, HTML5 менее строг в отношении синтаксиса. Например, закрывающие теги не всегда обязательны, и атрибуты могут быть без кавычек, если в этом нет необходимости.
- `Кроссбраузерная совместимость`: HTML5 стремится обеспечить лучшую совместимость между браузерами и устройствами, поддерживая мобильные платформы и улучшая работу с приложениями на стороне клиента.

`Основные отличия`:

- `Семантика и структура`: HTML5 добавляет больше семантических элементов, чего не было в HTML4.01 и XHTML1.0.
- `Мультимедиа и API`: HTML5 значительно улучшает поддержку мультимедиа и предоставляет мощные инструменты для создания веб-приложений.
- `Строгость синтаксиса`: HTML5 менее строг в отношении синтаксиса по сравнению с XHTML1.0, что делает его более гибким и удобным для разработчиков.
- `Современные веб-приложения`: HTML5 лучше адаптирован для современных веб-приложений и работы с динамическим контентом, чем его предшественники.

Таким образом, HTML5 представляет собой более современный и мощный стандарт, который пришел на смену устаревшим HTML4.01 и XHTML1.0, объединяя их лучшие практики и улучшая возможности веб-разработки.

##### Источники:

- [MDN HTML5](https://developer.mozilla.org/en-US/docs/Glossary/HTML5)
- [Спецификация HTML4.01](https://www.w3.org/TR/html4/?on)
- [Спецификация XHTML1.0](https://www.w3.org/TR/xhtml1/)

---

#### 6. Как следует оформлять страницу, содержимое которой может быть на разных языках?

**Ответ:**

Для оформления страницы, содержащей текст на разных языках, нужно следовать определенным правилам, чтобы обеспечить правильное отображение и доступность контента.

1. `Использование атрибута lang`:

- Каждый HTML-документ должен начинаться с указания основного языка содержимого с помощью атрибута `lang` в теге `<html>`. Например:
```html
<html lang="en">
```
- Если на странице используется несколько языков, каждый участок текста на другом языке должен быть заключен в соответствующий элемент с атрибутом `lang`. Например:
```html
<p>This is an English text. <span lang="es">Este es un texto en español.</span></p>
```
- Это помогает браузерам, поисковым системам и вспомогательным технологиям (например, скринридерам) правильно интерпретировать и произносить текст.

2. `Использование кодировок`:

- Убедиться, что документ использует правильную кодировку, например UTF-8, чтобы поддерживать символы всех языков. Это можно сделать с помощью мета-тега:
```html
<meta charset="UTF-8">
```
- UTF-8 позволяет отображать символы из различных языков и алфавитов, что особенно важно для мультиязычных страниц.

3. `Направление текста`:

- Для языков, которые читаются справа налево (например, арабский или иврит), нужно использовать атрибут `dir="rtl"`:
```html
<p dir="rtl">هذا نص باللغة العربية</p>
```
- Это гарантирует правильное отображение текста и выравнивание.

4. `Мета-данные для языковых предпочтений`:

- Для обеспечения правильной индексации мультиязычных страниц в поисковых системах, можно использовать тег `<link>` с атрибутом `hreflang`, указывающий на версии страницы на разных языках:
```html
<link rel="alternate" href="example.com/es" hreflang="es">
<link rel="alternate" href="example.com/fr" hreflang="fr">
```

5. `Адаптация интерфейса`:

- Элементы интерфейса, такие как кнопки и формы, должны быть переведены на соответствующий язык. Для этого могут использоваться технологии i18n (интернационализация) и l10n (локализация) в зависимости от того, как управляется содержимое на разных языках.

6. `Проверка правильности`:

Рекомендуется проверять страницу в различных браузерах и устройствах, чтобы убедиться, что все языковые версии отображаются корректно и что контент адаптирован для конкретных регионов (например, правильные форматы даты и времени).

7. `Правильное использование ресурсов`:

Убедиться, что внешние ресурсы, такие как шрифты, поддерживают нужные языковые символы. Если требуется поддержка специфичных символов, используй шрифты с расширенной поддержкой Unicode.

Cледуя этим рекомендациям, можно обеспечить правильное отображение мультиязычного контента на странице, улучшив доступность и удобство использования для пользователей.

##### Источники:

- [Спецификация](https://www.w3.org/International/questions/qa-html-language-declarations.en)
- [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang)
- [Дока](https://doka.guide/a11y/site-language/)

---

#### 7. На что необходимо обратить внимание при разработке мультиязычных сайтов?

**Ответ:**

При разработке мультиязычных сайтов важно учесть несколько ключевых аспектов, чтобы обеспечить удобство использования, корректное отображение и доступность контента для пользователей из разных языковых и культурных регионов.

1. `Структура сайта и URL`:

- Нужно продумать, как организовать структуру сайта для разных языков. Существуют несколько подходов:
    - Поддомены (например, `fr.example.com` для французского).
    - Подкаталоги (например, `example.com/fr/`).
    - Параметры URL (например, `example.com/?lang=fr`).
- Выбор подхода влияет на SEO и удобство навигации, поэтому его нужно продумывать с учетом особенностей проекта.

2. `SEO и hreflang`:

- Правильная настройка тегов `hreflang` для разных языковых версий страниц помогает поисковым системам понимать, на каких языках доступен контент и направлять пользователей на нужную языковую версию сайта.
- Важно также учитывать уникальность контента для каждой языковой версии и избегать дублирования.

3. `Локализация контента`:

- Перевод: Переводы должны быть качественными и выполненными носителями языка, чтобы избежать ошибок и непонимания.
- Культурные различия: Учесть, что контент должен быть адаптирован к культурным особенностям региона, включая использование правильных форматов дат, чисел, валюты, а также выбор изображений и примеров, соответствующих культуре.
- Ключевые слова и фразы: Убедиться, что ключевые слова и фразы, используемые в разных языковых версиях, соответствуют локальному контексту и не являются прямыми переводами, если это не уместно.

4. `Технические аспекты`:

- Кодировка: Используй кодировку UTF-8, чтобы поддерживать все символы различных языков.
- Атрибуты `lang` и `dir`: Следить за правильной установкой атрибутов `lang` для каждого языкового блока и `dir` для языков с направлением текста справа налево (RTL).
- Динамическая загрузка контента: Если сайт использует динамическую загрузку контента (например, с использованием JavaScript), убедиться, что мультиязычная поддержка работает корректно и для динамических элементов.

5. `Интерфейс и дизайн`:

- `UI/UX`: При проектировании интерфейса учитывай, что текст на разных языках может занимать больше или меньше места, что может повлиять на дизайн. Также следует предусмотреть поддержку RTL (right-to-left) языков.
- `Переключение языков`: Обеспечь удобный и интуитивно понятный способ переключения между языками на сайте. Пользователь должен легко находить и выбирать нужный язык.

6. `Тестирование и поддержка`:

- Тестирование: Важно протестировать сайт на всех языках, чтобы убедиться, что перевод корректен, форматирование правильно отображается, и все элементы интерфейса адаптированы.
- Обратная связь: Учитывай отзывы пользователей из разных регионов и поддерживай сайт на всех языках, чтобы обеспечить актуальность контента и устранение возможных ошибок.

7. `Правовые и регуляторные аспекты`:

- В некоторых странах существуют требования к наличию определенных языковых версий сайта или обязательным юридическим текстам на местном языке. Например, в Канаде требуется наличие версии на французском языке для части контента.

Разработка мультиязычного сайта требует комплексного подхода, охватывающего как технические, так и культурные аспекты. Важно не только перевести текст, но и адаптировать сайт к особенностям аудитории, чтобы обеспечить его удобство и эффективность.

##### Источники:

- [Google developers](https://developers.google.com/search/docs/specialty/international/managing-multi-regional-sites?hl=ru)
- [MDN](https://developer.mozilla.org/en-US/docs/Glossary/Internationalization)
- [Спецификация](https://www.w3.org/International/techniques/developing-schemas)

---

#### 8. Для чего нужны data-атрибуты?

**Ответ:**

data-атрибуты позволяют хранить пользовательские данные прямо в HTML-элементах без нарушения семантики кода. Они были введены в HTML5 и широко используются для передачи данных в JavaScript.

data-атрибуты удобны для хранения информации, связанной с элементом, такой как идентификаторы, статусы или метаданные, которую затем можно использовать в скриптах для изменения поведения страницы. Их можно легко прочитать и изменить с помощью свойства dataset в JavaScript.

Основные преимущества data-атрибутов — это универсальность и простота использования. Они позволяют хранить данные прямо в HTML, не создавая лишних элементов и не нарушая структуры страницы. Однако важно помнить, что data-атрибуты не подходят для хранения конфиденциальной информации, так как они видны в коде страницы.

##### Источники:

- [MDN](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes)
- [Спецификация](https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)

---

#### 9. Представьте HTML5 как открытую веб-платформу. Из каких блоков состоит HTML5?

**Ответ:**

HTML5 — это не просто новая версия языка разметки, но и целая экосистема, которая включает в себя несколько ключевых блоков. Эти блоки обеспечивают создание мощных и интерактивных веб-приложений.

1. `Семантические элементы`: HTML5 ввел новые теги, такие как `<header>`, `<footer>`, `<article>`, `<section>`, которые делают структуру документа более понятной как для разработчиков, так и для поисковых систем.

2. `Мультимедиа`: HTML5 включает встроенные элементы `<audio>` и `<video>`, которые позволяют воспроизводить медиафайлы без использования сторонних плагинов, таких как Flash.

3. `Графика и анимация`: Новый элемент `<canvas>` предоставляет возможность рисования и создания анимаций с помощью JavaScript, что открывает путь для создания игр и динамических графических приложений прямо в браузере. Также поддерживается встроенная графика через `<svg>`.

4. `Формы`: HTML5 улучшил работу с формами, добавив новые типы полей ввода, такие как `email`, `date`, `number`, а также встроенную валидацию данных на стороне клиента, что делает формы более интерактивными и удобными.

5. `API и JavaScript`: HTML5 предлагает множество новых API, таких как:
- Geolocation API для работы с геолокацией,
- LocalStorage и SessionStorage для хранения данных в браузере,
- WebSocket API для поддержания постоянного соединения с сервером в реальном времени,
- History API для управления историей браузера без перезагрузки страницы.

6. `Работа в оффлайн-режиме`: HTML5 поддерживает оффлайн-режим через Application Cache и Service Workers, что позволяет веб-приложениям работать без подключения к интернету.

7. `CSS3 и новые стили`: Хотя CSS3 не является частью HTML5, они тесно связаны. CSS3 предоставляет возможности для создания сложных анимаций, переходов и макетов, что в совокупности с HTML5 позволяет создавать более интерактивные и динамичные веб-страницы.

8. `Поддержка новых форматов данных`: HTML5 поддерживает новые форматы данных, такие как JSON и XML, а также улучшенную работу с протоколами, например, с WebRTC для передачи потоковых данных в реальном времени.

##### Источники:

- [MDN](https://developer.mozilla.org/en-US/docs/Glossary/HTML5)
- [Спецификация](https://html.spec.whatwg.org/multipage/)

---

#### 10. Объясните разницу между cookie, sessionStorage и localStorage?

**Ответ:**

`Cookie`, `sessionStorage` и `localStorage` — это три способа хранения данных на стороне клиента в браузере, но они различаются по функциональности, времени жизни и доступности данных.

1. `Cookie`:

- Назначение: Cookie используются для хранения небольших данных (до 4KB), которые могут быть отправлены на сервер при каждом запросе. Они часто применяются для авторизации, сохранения пользовательских настроек и сессий.
- Время жизни: Cookie имеют срок жизни, который задается через атрибут `expires` или `max-age`. Они могут быть временными (удаляются при закрытии браузера) или постоянными (удерживаются до истечения срока действия).
- Доступность: Cookie доступны как на клиенте через JavaScript, так и на сервере через HTTP-заголовки. Это делает их подходящими для передачи информации между клиентом и сервером.
- Безопасность: Можно задать атрибуты `HttpOnly` (делает cookie недоступными для JavaScript) и `Secure` (разрешает отправку только по HTTPS).

2. `sessionStorage`:

- Назначение: sessionStorage используется для хранения данных в пределах одной сессии браузера. Это полезно для данных, которые нужны только во время текущей сессии и не должны сохраняться после закрытия вкладки или окна браузера.
- Время жизни: Данные в sessionStorage хранятся до тех пор, пока вкладка или окно браузера открыты. Закрытие вкладки или перезагрузка страницы удаляет данные.
- Доступность: Данные доступны только в рамках одной вкладки или окна. Если открыть сайт в новой вкладке, sessionStorage будет пустым.

3. `localStorage`:

- Назначение: localStorage используется для хранения данных, которые должны оставаться доступными даже после закрытия браузера или перезагрузки страницы. Это удобно для сохранения настроек пользователя, корзин покупок и других данных, которые нужно хранить долгое время.
- Время жизни: Данные в localStorage не имеют срока действия и сохраняются до тех пор, пока их не удалит сам пользователь или скрипт.
- Доступность: Данные доступны во всех вкладках и окнах для данного домена. Если открыть сайт в новой вкладке, localStorage будет содержать те же данные.

`Итог`:
- Cookie: Подходят для хранения данных, которые должны быть переданы на сервер с каждым запросом. Данные могут быть доступны как на клиенте, так и на сервере.
- sessionStorage: Используется для данных, которые нужны только в рамках одной сессии и не должны сохраняться после закрытия вкладки.
- localStorage: Подходит для хранения данных, которые должны сохраняться на длительное время и быть доступны на всех вкладках.

##### Источники:

- [MDN cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
- [MDN sessionStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)
- [MDN localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)
- [Дока cookie](https://doka.guide/js/cookie/)
- [Дока localStorage](https://doka.guide/js/local-storage/)
- [Дока sessionStorage](https://doka.guide/js/session-storage/)

---

#### 11. Объясните разницу между `<script>`, `<script async>` и `<script defer>`?

**Ответ:**

**Разница между `<script>`, `<script async>` и `<script defer>` заключается в том, как и когда загружается и выполняется скрипт в процессе рендеринга страницы.**

1. **`<script>` (без атрибутов)**:
   - Скрипты без атрибутов загружаются и выполняются синхронно. Это означает, что при их загрузке браузер приостанавливает обработку HTML-документа до тех пор, пока скрипт не будет загружен и выполнен. Это может замедлять рендеринг страницы, особенно если скрипты находятся в `<head>`.
   

   Когда браузер достигает этого тега, он приостанавливает разбор HTML, загружает и выполняет `script.js`, а затем продолжает обработку страницы.

2. **`<script async>`**:
   - Скрипты с атрибутом `async` загружаются асинхронно, что означает, что браузер продолжает разбор HTML-документа, пока скрипт загружается в фоновом режиме. После загрузки скрипт сразу выполняется, что может прерывать разбор HTML в случайный момент.
   - Подходит для скриптов, которые не зависят от других частей страницы или других скриптов.
   
   В этом случае браузер загружает `script.js` параллельно с разбором HTML, а затем выполняет его сразу по завершении загрузки.

3. **`<script defer>`**:
   - Скрипты с атрибутом `defer` также загружаются асинхронно, но их выполнение откладывается до тех пор, пока весь HTML-документ не будет разобран. Это гарантирует, что скрипт не нарушит процесс рендеринга страницы.
   - Атрибут `defer` особенно полезен для скриптов, которые зависят от структуры DOM, так как они выполняются только после того, как весь HTML будет доступен.

   В этом случае `script.js` загружается в фоновом режиме и выполняется только после полной загрузки и разбора HTML-документа.

**Основные различия**:
- Скрипты без атрибутов загружаются и выполняются синхронно, блокируя разбор HTML.
- Скрипты с атрибутом `async` загружаются асинхронно и выполняются сразу после загрузки, что может приостановить разбор HTML.
- Скрипты с атрибутом `defer` загружаются асинхронно, но их выполнение откладывается до завершения разбора HTML.

##### Источники:

- [Спецификация](https://html.spec.whatwg.org/multipage/scripting.html#attr-script-async)
- [Дока](https://doka.guide/html/script/)

---

#### 12. Почему хорошей практикой считается располагать `<link>` для подключения CSS между `<head></head>`, а `<script>` для подключения JS ставить перед `</body>`? Знаете ли вы исключения?

**Ответ:**

Расположение `<link>` для подключения CSS внутри `<head>` и `<script>` перед закрывающим тегом `</body>` считается хорошей практикой по нескольким причинам, связанным с оптимизацией производительности и опытом пользователей.

1. **Почему `<link>` с CSS следует размещать в `<head>`?**
   - **Задержка рендеринга**: CSS-стили необходимы для корректного отображения страницы. Если стили загружаются поздно, это может вызвать "моргание" контента (FOUT — Flash of Unstyled Text), когда браузер сначала отображает страницу без стилей, а затем перерисовывает её после загрузки CSS. Это ухудшает восприятие пользователем.
   - **Блокирующее поведение**: Браузеры не рендерят страницу, пока не загрузят все CSS, находящиеся в `<head>`. Это поведение гарантирует, что страница будет загружена корректно, с правильными стилями, с самого начала. Поэтому стили нужно подключать как можно раньше — в секции `<head>`, чтобы минимизировать задержки рендеринга.

   Пример:
   ```html
   <head>
     <link rel="stylesheet" href="styles.css">
   </head>
   ```

2. **Почему `<script>` для подключения JS ставят перед закрывающим тегом `</body>`?**
   - **Блокировка рендеринга**: Скрипты по умолчанию блокируют парсинг HTML, то есть пока скрипт загружается и выполняется, браузер приостанавливает разбор HTML-документа. Если скрипт располагается в начале страницы или в `<head>`, это замедлит загрузку и отображение контента.
   - **Завершённая разметка**: Скрипты, подключённые перед закрывающим тегом `</body>`, выполняются после того, как весь HTML уже разобран и DOM-дерево готово. Это особенно важно для скриптов, которые манипулируют элементами страницы, так как все элементы будут уже доступны.
   
   Пример:
   ```html
   <body>
     <!-- Содержание страницы -->
     <script src="script.js"></script>
   </body>
   ```

3. **Исключения**:
   - **Необходимость загрузки JavaScript раньше**: В некоторых случаях скрипты могут быть необходимы на ранних стадиях загрузки страницы. Например, скрипты аналитики или трекеры часто подключают в `<head>` с атрибутом `async` или `defer`, чтобы они не блокировали рендеринг.
   - **`async` и `defer`**: Эти атрибуты позволяют загружать скрипты асинхронно (без блокировки рендеринга). Использование атрибута `async` для скриптов, не зависящих от DOM, или `defer` для тех, которые должны выполняться после разбора документа, является исключением, когда скрипты могут располагаться в `<head>`, не влияя на скорость рендеринга.

   Пример использования `defer` в `<head>`:
   ```html
   <head>
     <script defer src="script.js"></script>
   </head>
   ```

**Итог**:
- **CSS**: Размещение в `<head>` обеспечивает быструю и стабильную загрузку стилей.
- **JS**: Размещение перед `</body>` минимизирует блокировку рендеринга.
- **Исключения**: Атрибуты `async` и `defer` позволяют размещать скрипты в `<head>`, не ухудшая производительность.

##### Источники:

- [MDN `<script>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async)
- [MDN CSS](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#stylesheet).

---

#### 13. Что такое прогрессивный рендеринг?

**Ответ:**

**Прогрессивный рендеринг** — это методика оптимизации рендеринга веб-страниц, которая позволяет браузеру постепенно отображать контент по мере его загрузки, вместо того чтобы ждать полной загрузки всех ресурсов страницы. Это улучшает восприятие скорости загрузки пользователями и создает впечатление более быстрого отклика.

Основные техники прогрессивного рендеринга:

1. **Ленивая загрузка (Lazy Loading)**:
   - Ленивая загрузка применяется для изображений и других тяжелых ресурсов, таких как видео. Вместо того чтобы загружать все изображения сразу, они загружаются только тогда, когда пользователь прокручивает страницу до них. Это сокращает время начальной загрузки и экономит сетевые ресурсы.
   
   Пример:
   ```html
   <img src="placeholder.jpg" data-src="actual-image.jpg" loading="lazy" alt="Example Image">
   ```
   Здесь изображение загружается только тогда, когда оно становится видимым.

2. **Загрузка важных ресурсов в первую очередь (Critical Rendering Path)**:
   - Важные для рендеринга ресурсы, такие как стили, загружаются первыми, чтобы страница могла начать отображаться как можно быстрее. Для этого можно выделить "критический" CSS, который необходим для первоначальной отрисовки, и встроить его в HTML. Остальные стили могут быть загружены асинхронно.
   
   Пример:
   ```html
   <style>
     /* Критический CSS для основного рендеринга */
   </style>
   <link rel="stylesheet" href="styles.css" media="print" onload="this.media='all'">
   ```

3. **Инкрементальная отрисовка данных (Progressive Data Rendering)**:
   - Когда данные поступают от сервера, можно начать отображать уже загруженные части данных, не дожидаясь полной загрузки. Например, в длинных списках можно отрисовывать первые несколько элементов, пока остальная часть данных загружается в фоновом режиме.

   Пример:
   В случае серверного рендеринга с использованием технологий, таких как React Server Components или серверный рендеринг в Next.js, данные можно отдавать и отображать по частям.

4. **Скелетные экраны (Skeleton Screens)**:
   - Скелетные экраны представляют собой упрощенные версии интерфейса (например, серые блоки вместо изображений и текста), которые отображаются до тех пор, пока не будет загружен реальный контент. Это помогает пользователям увидеть, что происходит загрузка, и создает иллюзию быстрого отклика страницы.

   Пример:
   ```html
   <div class="skeleton">
     <!-- Блоки-заполнители -->
   </div>
   ```

Преимущества прогрессивного рендеринга:
   - **Улучшенное восприятие скорости**: Пользователи быстрее видят контент, даже если он загружается поэтапно.
   - **Меньшая задержка**: Вместо того чтобы ждать полной загрузки страницы, критический контент отображается раньше.
   - **Оптимизация ресурсов**: Ненужные ресурсы можно загружать только тогда, когда они действительно нужны, экономя трафик и ускоряя начальный рендеринг.

Прогрессивный рендеринг активно используется для улучшения пользовательского опыта, особенно на медленных интернет-соединениях или устройствах с низкой производительностью. Его применение улучшает восприятие скорости сайта, даже если общая загрузка продолжается в фоне.

##### Источники:

- [MDN](https://developer.mozilla.org/en-US/docs/Web/Performance/Rendering_critical_path).

---

#### 14. Для чего используется атрибут `srcset` в теге изображения? Опишите процесс, который браузер использует при обработке содержимого этого атрибута.

**Ответ:**

**Атрибут `srcset`** в теге `<img>` используется для предоставления браузеру нескольких вариантов изображения с различными разрешениями или размерами. Это позволяет браузеру выбрать наиболее подходящий вариант изображения в зависимости от характеристик устройства пользователя, таких как плотность пикселей (DPR — device pixel ratio) или ширина экрана.

Зачем нужен `srcset`?
`srcset` используется для улучшения производительности и качества изображений на разных устройствах. Например, изображения с высоким разрешением могут быть загружены для экранов Retina, в то время как на устройствах с низким разрешением могут быть использованы изображения меньшего размера, что экономит трафик и ускоряет загрузку.

Пример использования `srcset`:

```html
<img 
  src="image-320w.jpg" 
  srcset="image-320w.jpg 320w, image-640w.jpg 640w, image-1280w.jpg 1280w" 
  sizes="(max-width: 600px) 480px, 800px" 
  alt="Example Image">
```

Как работает атрибут `srcset`?

В примере выше атрибут `srcset` предоставляет браузеру три варианта одного и того же изображения с разной шириной:
- `image-320w.jpg 320w` — изображение шириной 320 пикселей.
- `image-640w.jpg 640w` — изображение шириной 640 пикселей.
- `image-1280w.jpg 1280w` — изображение шириной 1280 пикселей.

Процесс выбора изображения браузером:
1. **Анализ параметров устройства**:
   - Браузер учитывает ширину экрана и плотность пикселей устройства (DPR). Например, на экране с высокой плотностью пикселей (Retina) может потребоваться изображение с более высоким разрешением.
   
2. **Оценка атрибута `sizes` (если он указан)**:
   - Атрибут `sizes` сообщает браузеру, каким будет фактический размер изображения на экране в различных условиях. Это помогает браузеру заранее рассчитать, какое изображение выбрать.
   - В примере выше:
     ```html
     sizes="(max-width: 600px) 480px, 800px"
     ```
     Это значит, что если ширина экрана меньше 600 пикселей, браузер должен выбрать изображение, которое отобразится с шириной 480 пикселей. В остальных случаях изображение будет иметь ширину 800 пикселей.

3. **Выбор наиболее подходящего изображения**:
   - После того как браузер получил информацию о ширине отображаемого изображения (на основании атрибута `sizes` и характеристик устройства), он выбирает изображение из `srcset`, которое лучше всего соответствует этим условиям.
   - Например, если экран устройства имеет ширину 500px, а плотность пикселей (DPR) равна 2, браузер может выбрать изображение шириной 1280 пикселей, чтобы оно выглядело четким на высокоплотных экранах.

Пример с изображениями для разных плотностей пикселей (Retina):
```html
<img 
  src="image.jpg" 
  srcset="image.jpg 1x, image-2x.jpg 2x" 
  alt="Example Image">
```
В этом случае:
- `image.jpg 1x` используется для стандартных экранов.
- `image-2x.jpg 2x` загружается для экранов с высокой плотностью пикселей (например, Retina).

Итог:
Атрибут `srcset` позволяет:
- Поддерживать адаптивные изображения для различных устройств и экранов.
- Увеличить производительность за счет выбора меньших изображений для устройств с низким разрешением.
- Повысить качество отображения на экранах с высокой плотностью пикселей.

**Пример сценария**:
- Пользователь с устройством, у которого ширина экрана 400px и DPR 2, может загрузить изображение 1280px (так как это наиболее подходящий размер для такого устройства).
- Пользователь с экраном шириной 320px и DPR 1 может загрузить изображение размером 320px.

##### Источники:

- [MDN](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images).

---

#### 15. Приходилось ли вам работать с языками HTML-шаблонизации?

**Ответ:**

**Да, мне приходилось работать с языками HTML-шаблонизации.**

HTML-шаблонизация — это процесс динамического создания HTML-кода на сервере или клиенте с использованием шаблонных языков. Шаблонизаторы позволяют смешивать статический HTML с динамическими данными, чтобы генерировать страницы на основе входных данных (например, данных от API или базы данных).

Популярные языки шаблонизации:

1. **Handlebars.js**
   - Это клиентский шаблонизатор, который использует маркеры (`{{ }}`) для подстановки динамических данных.
   - Пример:
     ```html
     <script id="entry-template" type="text/x-handlebars-template">
       <h1>{{title}}</h1>
       <p>{{description}}</p>
     </script>
     ```

2. **Pug (ранее Jade)**
   - Это шаблонизатор для Node.js с лаконичным синтаксисом, где отсутствуют закрывающие теги.
   - Пример:
     ```pug
     html
       head
         title= title
       body
         h1= heading
         p= description
     ```

3. **EJS (Embedded JavaScript)**
   - Шаблонизатор для встраивания JavaScript в HTML, позволяющий использовать JS-логику прямо в шаблоне.
   - Пример:
     ```html
     <h1><%= title %></h1>
     <p><%= description %></p>
     ```

4. **Jinja (для Python)**
   - Шаблонизатор, который часто используется в связке с Flask или Django для серверной генерации HTML.
   - Пример:
     ```html
     <h1>{{ title }}</h1>
     <p>{{ description }}</p>
     ```

Преимущества использования HTML-шаблонизаторов:

1. **Чистый код**:
   - Шаблонизаторы помогают отделить логику от представления, делая код более структурированным и легко читаемым.

2. **Динамическое содержание**:
   - Легко вставлять динамические данные в HTML, что значительно упрощает разработку динамических страниц.

3. **Повторное использование**:
   - Шаблоны позволяют переиспользовать общие части кода, такие как хедеры или футеры, что улучшает поддержку кода и снижает его дублирование.

Недостатки использования HTML-шаблонизаторов:

1. **Дополнительная сложность**:
   - Добавление шаблонизаторов увеличивает сложность проекта. Нужно не только уметь писать на HTML, но и владеть шаблонным языком. Это может увеличить порог вхождения для новых разработчиков.

2. **Пониженная производительность на клиенте**:
   - При использовании клиентских шаблонизаторов (таких как Handlebars.js), весь процесс рендеринга происходит в браузере, что может замедлить работу на слабых устройствах или при сложных шаблонах с большим количеством данных.

3. **Серверная нагрузка**:
   - В случае серверных шаблонизаторов, таких как Pug или Jinja, процесс генерации HTML происходит на сервере. При большом количестве запросов сервер может стать узким местом, если генерация сложных шаблонов потребует значительных ресурсов.

4. **Ограниченная гибкость**:
   - Шаблонизаторы, как правило, предоставляют ограниченные возможности для выполнения сложной логики. Их задача — генерировать HTML, а не обрабатывать данные. Для более сложных манипуляций может потребоваться дополнительный код на сервере или клиенте, что усложняет разработку.

5. **Переход к компонентным подходам**:
   - С развитием компонентных фреймворков (React, Vue, Angular), которые включают собственные решения для шаблонизации и логики, классические шаблонизаторы постепенно отходят на второй план. Компонентные подходы часто оказываются более гибкими и производительными.

Итог:

HTML-шаблонизаторы могут значительно упростить разработку динамических веб-страниц за счёт отделения логики от представления и поддержки повторного использования кода. Однако они также добавляют сложность и могут иметь проблемы с производительностью, особенно на клиентской стороне или при большом объеме данных.

---