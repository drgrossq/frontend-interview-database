#### 1. Свойство display - основные значения и как они работают.


Свойство `display` меняет стандартный тип отображения на произвольный. `display` принимает множество значений, но основные - это: 
- `none` - полностью скрывает элемент со страницы, не удаляя его при этом из HTML-разметки
- `block` - размер определяется размером самого блока заданными в стилях, но сам блок занимает всю свободную ширину экрана
- `inline` - элементы расположены в одну строку и их размер зависит от содержимого
- `inline-block` - элементы расположены в одну строку, но элементам можно задавать размеры
- `flex` - элемент становится флекс-контейнером, ведёт себя как блочный, а вложенные элементы становятся флекс-элементами
- `grid` - элемент становится грид-контейнером. Снаружи грид-контейнер ведёт себя как блок. Дочерние элементы такого контейнера начинают подчиняться правилам грид-раскладки


##### Источники:

- [Спецификация](https://www.w3.org/TR/css-display-3/)
- [Дока](https://doka.guide/css/display/)
- [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/display)

---

#### 2. @keyframes - для чего нужно и как использовать?


Директива `@keyframes` используется для создания _ключевых кадров_ CSS-анимаций. После ключевого слова `@keyframes` мы должны написать имя анимации. Оно понадобится нам, чтобы связать анимацию для конкретного элемента с ключевыми кадрами. Ключевые кадры могут прописываться при помощи ключевых слов from (начальный кадр) и to (конечный кадр). Если же кадров больше двух, то можно использовать проценты. Пример:

```CSS
div {
  animation: diagonal-slide 1s infinite;
}

@keyframes diagonal-slide {

  from {
    left: 0;
    top: 0;
  }

  to {
    left: 100px;
    top: 100px;
  }

}
```

##### Источники:

- [Спецификация](https://www.w3.org/TR/css-animations-1/#keyframes)
- [Дока](https://doka.guide/css/keyframes/)
- [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes)

---

#### 3. Что делает box-sizing: border-box?

Свойство `box-sizing` определяет как вычисляется общая ширина и высота элемента. По умолчанию размером элемента считается размер контентной области. Если кроме `width` и `height` указать ещё и `padding` с `border`, то браузер посчитает размер элемента как `width + padding * 2 + border * 2 и height + padding * 2 + border * 2`. Если задать значение `border-box` для свойства `box-sizing`, то браузер изменит принцип расчёта и `padding` с `border` уже будут включены в `width` и `height`.

##### Источники:

- [Спецификация](https://www.w3.org/TR/css-sizing-3/#box-sizing)
- [Дока](https://doka.guide/css/box-sizing/)
- [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing)

---

#### 4. Разница между margin и padding?

`margin` - задаёт размер внешнего отступа вокруг элемента. Верхний и нижний отступы не работают для элементов `<span>`, `<code>` и других строчных элементов. Выход в данной ситуации — сделать строчные элементы строчно-блочными (`inline-block`) или блочными (`block`).
`padding` - устанавливает внутренние отступы со всех сторон элемента. Область отступов это пространство между содержанием элемента и его границей. Отрицательные значения не допускаются.

![CSS Box Model](../img/CSS%20Box%20Model.png)

##### Источники:

- [Спецификация по margin](https://drafts.csswg.org/css-box/#margins)
- [Спецификация по padding](https://drafts.csswg.org/css-box/#paddings)
- [Дока по margin](https://doka.guide/css/margin/)
- [Дока по padding](https://doka.guide/css/padding/)
- [MDN по margin](https://developer.mozilla.org/en-US/docs/Web/CSS/margin)
- [MDN по padding](https://developer.mozilla.org/en-US/docs/Web/CSS/padding)

---

#### 5. Чем border отличается от outline?

`outline` - это линия за пределами рамки элемента и в отличии от `border` не влияет на размеры элемента т.к. `outline` не является частью блочной модели CSS. 

##### Источники:

- [Спецификация по border](https://www.w3.org/TR/css-backgrounds-3/#propdef-border)
- [Спецификация по outline](https://www.w3.org/TR/css-ui-4/#outline-props)
- [Дока по border](https://doka.guide/css/border/)
- [Дока по outline](https://doka.guide/css/outline/)
- [MDN по border](https://developer.mozilla.org/en-US/docs/Web/CSS/border)
- [MDN по outline](https://developer.mozilla.org/en-US/docs/Web/CSS/outline)

---

#### 6. Что такое специфичность селекторов CSS и как она работает?

**Ответ:**

**Специфичность селекторов CSS** — это механизм, который браузер использует для определения приоритета различных CSS-правил, применяемых к одному и тому же элементу. Специфичность вычисляется на основе типа селекторов, используемых в CSS-правилах, и помогает решить, какое из конфликтующих правил должно быть применено.

Как работает специфичность:

Специфичность выражается в виде числового значения, которое состоит из четырёх частей (обычно представляется как "четырёхзначное число"). Каждому типу селектора присваивается определённый вес:

1. **Inline-стили** (применяемые через атрибут `style` в HTML) имеют наибольший вес. Например:
   ```html
   <div style="color: red;"></div>
   ```
   Этот стиль имеет самую высокую специфичность и будет всегда иметь приоритет перед внешними стилями.

2. **ID-селекторы** (`#id`) имеют высокую специфичность. Пример:
   ```css
   #myId {
     color: blue;
   }
   ```

3. **Классы** (`.class`), атрибуты (`[type="text"]`) и псевдоклассы (`:hover`, `:nth-child`) имеют меньшую специфичность, чем ID-селекторы. Пример:
   ```css
   .myClass {
     color: green;
   }
   ```

4. **Теговые селекторы** (`div`, `p`, `h1` и т.д.) и псевдоэлементы (`::before`, `::after`) имеют самую низкую специфичность. Пример:
   ```css
   div {
     color: black;
   }
   ```

Пример работы специфичности:

```html
<div id="example" class="box"></div>
```

```css
div {
  color: black; /* Специфичность: 0,0,0,1 */
}

.box {
  color: green; /* Специфичность: 0,0,1,0 */
}

#example {
  color: blue; /* Специфичность: 0,1,0,0 */
}
```

В этом примере браузер выберет **синий цвет** для текста элемента, так как селектор `#example` имеет самую высокую специфичность (0,1,0,0). Правило с селектором класса `.box` имеет меньшую специфичность (0,0,1,0), а правило для тега `div` — самую низкую (0,0,0,1).

Способ вычисления специфичности:

- **Inline-стили**: 1,0,0,0
- **ID-селекторы**: 0,1,0,0
- **Классы, атрибуты, псевдоклассы**: 0,0,1,0
- **Теги и псевдоэлементы**: 0,0,0,1

Важные моменты:
- **`!important`**: Этот флаг всегда имеет приоритет над другими правилами, но он не отменяет inline-стили с `!important`.
- Если два правила имеют одинаковую специфичность, применяется то, которое определено последним в CSS-файле.

Итог:
**Специфичность селекторов CSS** — это числовое выражение, определяющее приоритет стилей. Чем выше специфичность селектора, тем больше вероятность, что его стили будут применены к элементу.

##### Источники: 

- [MDN](https://developer.mozilla.org/ru/docs/Web/CSS/Specificity).

---

#### 7. В чём разница между "сбросом" (resetting) и "нормализацией" (normalizing) CSS? Что бы вы выбрали и почему?

**Ответ:**

Разница между "сбросом" (resetting) и "нормализацией" (normalizing) CSS заключается в их подходе к устранению различий в стилях между браузерами.

1. **Сброс (resetting) CSS**:
   - CSS-сброс предполагает **удаление всех встроенных стилей** браузера. Это делает все элементы на странице полностью унифицированными по стилю и лишёнными дефолтного форматирования, которое браузеры применяют по умолчанию (например, отступы у списков, размер шрифтов заголовков и т.д.).
   - Один из самых известных примеров — это CSS-файл от **Eric Meyer**:
     ```css
     /* Пример сброса CSS */
     html, body, div, span, applet, object, iframe,
     h1, h2, h3, h4, h5, h6, p, blockquote, pre,
     a, abbr, acronym, address, big, cite, code,
     del, dfn, em, img, ins, kbd, q, s, samp,
     small, strike, strong, sub, sup, tt, var,
     b, u, i, center,
     dl, dt, dd, ol, ul, li,
     fieldset, form, label, legend,
     table, caption, tbody, tfoot, thead, tr, th, td,
     article, aside, canvas, details, embed,
     figure, figcaption, footer, header, hgroup,
     menu, nav, output, ruby, section, summary,
     time, mark, audio, video {
       margin: 0;
       padding: 0;
       border: 0;
       font-size: 100%;
       font: inherit;
       vertical-align: baseline;
     }
     ```

   - Основная цель сброса CSS — сделать все элементы "чистыми", чтобы начать стилизацию с нуля.

2. **Нормализация (normalizing) CSS**:
   - Нормализация CSS не сбрасывает все стили до нуля, а вместо этого **делает дефолтные стили браузеров более согласованными**. Она сохраняет полезные стили (например, отступы у заголовков, шрифты у параграфов), но устраняет кроссбраузерные несоответствия.
   - Пример: **Normalize.css** — это популярная библиотека для нормализации.
     ```css
     /* Пример нормализации CSS */
     html {
       line-height: 1.15; /* Исправляет баг размера шрифта в некоторых браузерах */
       -webkit-text-size-adjust: 100%; /* Избегает автонастройки текста в мобильных браузерах */
     }

     body {
       margin: 0; /* Удаляет дефолтные отступы у body */
     }
     ```

   - Цель нормализации — **сохранить полезные стили** и устранить только несовместимости между браузерами.

Что выбрать и почему?

- **Выбор зависит от контекста проекта**.
   - **Сброс CSS** стоит выбрать, если вы хотите **абсолютный контроль** над стилями на странице и вам нужно минимизировать влияние встроенных браузерных стилей. Это полезно для проектов с полным кастомным дизайном, где каждый элемент будет стилизован вручную.
   - **Нормализация CSS** предпочтительна, если вы хотите **сохранить полезные стандартные стили**, но при этом устранить кроссбраузерные баги. Это хороший выбор для большинства проектов, поскольку он не требует начинать стилизацию с нуля и помогает избежать ненужной работы по восстановлению полезных дефолтных стилей.

##### Источники: 

- [Normalize.css](https://necolas.github.io/normalize.css/)

---

#### 8. Опишите, что такое `float` и как они работают. 

**Ответ:**

**Флоаты (`float`)** в CSS — это свойство, которое позволяет элементам "плавать" слева или справа внутри контейнера, при этом последующий контент обтекает их. Изначально свойство `float` было разработано для создания обтекания текста вокруг изображений, но со временем его стали использовать для создания макетов.

Как работает `float`:

- **Значения `float`**:
  - `left`: Элемент будет "плавать" слева, и другие элементы будут обтекать его справа.
  - `right`: Элемент будет "плавать" справа, и другие элементы будут обтекать его слева.
  - `none`: Значение по умолчанию. Элемент остаётся в нормальном потоке, не плавая.

- Когда элемент имеет свойство `float`, он **выходит из нормального потока документа**. Это означает, что другие элементы будут вести себя так, как если бы этот элемент не существовал, обтекая его.

Проблемы с флоатами:

Одной из распространённых проблем с флоатами является **"схлопывание" родительского контейнера**. Поскольку плавающие элементы выводятся из потока документа, родительский контейнер не учитывает их высоту, что приводит к визуальному схлопыванию контейнера.

Решение с использованием `::after` (clearfix):

Технику clearfix можно использовать для решения проблемы схлопывания. Она добавляет псевдоэлемент, который очищает обтекание и корректно учитывает плавающие элементы.

Пример кода с `::after`:

```html
<div class="container">
  <div class="box left">Левый блок</div>
  <div class="box right">Правый блок</div>
</div>
```

```css
/* Clearfix для очистки флоатов */
.container::after {
  content: "";
  display: table;
  clear: both;
}

.box {
  width: 200px;
  height: 100px;
  background-color: lightblue;
  margin: 10px;
}

.left {
  float: left;
}

.right {
  float: right;
}
```

Объяснение:

1. **Плавающие элементы**: В этом примере два элемента с классами `.left` и `.right` плавают слева и справа соответственно. Они выводятся из нормального потока документа и прижимаются к краям контейнера.
   
2. **Проблема схлопывания**: Если бы не было техники clearfix, родительский контейнер `.container` не учитывал бы высоту своих дочерних элементов с `float`, и его высота была бы равна нулю.

3. **Решение через `::after`**: С помощью псевдоэлемента `::after` и свойства `clear: both`, добавляемого к контейнеру, мы обеспечиваем, что контейнер учитывает плавающие элементы. Псевдоэлемент действует как блок, который завершает обтекание и заставляет родительский контейнер "захватывать" высоту всех его дочерних элементов.

Итог:

Свойство `float` в CSS позволяет элементам "плавать" слева или справа, выводя их из нормального потока документа, а другие элементы обтекают их. Однако для предотвращения проблем с высотой родительских контейнеров следует использовать технику **clearfix**, которая с помощью псевдоэлемента `::after` решает проблему схлопывания контейнеров, делая код более устойчивым и поддерживаемым.

##### Источники:

- [MDN](https://developer.mozilla.org/ru/docs/Web/CSS/float)
- [clearfix](https://css-tricks.com/snippets/css/clear-fix/)

---

#### 9. Опишите z-index и как формируется контекст наложения (stacking context).

**Ответ:**

**`z-index`** — это CSS-свойство, которое управляет вертикальным расположением элементов относительно друг друга на оси z (глубине), что особенно важно, когда элементы перекрывают друг друга. Оно используется для того, чтобы определить, какой элемент должен находиться "выше" или "ниже" по отношению к другим элементам.

Как работает `z-index`:

- **Значения `z-index`**:
  - `z-index` может принимать положительные, отрицательные или нулевые значения.
  - Элемент с более высоким значением `z-index` будет отображаться поверх элемента с меньшим значением `z-index`, если они перекрываются.
  - Элемент по умолчанию имеет значение `z-index: auto`, которое соответствует уровню 0, и его порядок отображения определяется порядком в DOM.

Пример:
```html
<div class="box1">Элемент 1</div>
<div class="box2">Элемент 2</div>
```

```css
.box1 {
  position: relative;
  z-index: 10; /* Этот элемент будет выше */
  background-color: lightblue;
}

.box2 {
  position: relative;
  z-index: 5; /* Этот элемент будет ниже */
  background-color: lightgreen;
}
```

В этом примере элемент с `z-index: 10` будет отображаться поверх элемента с `z-index: 5`.

Контекст наложения (stacking context):

**Контекст наложения** — это особая система для управления порядком отображения элементов. Он создаёт локальный уровень для наложения, в пределах которого элементы сортируются по оси z. Если элементы находятся в разных контекстах наложения, их `z-index` сравнивается только внутри этих контекстов, но не между ними.

Как создаётся контекст наложения:

1. **Основные триггеры для создания контекста наложения**:
   - Любой элемент с **позиционированием** (`position: relative`, `absolute`, `fixed` или `sticky`) и незначением `z-index: auto`.
   - Элементы с **CSS-свойством `opacity`** менее 1 создают новый контекст наложения.
   - Элементы с **CSS-свойством `transform`, `filter`, `perspective`**, а также с использованием **`will-change`** также создают контекст наложения.
   - Элементы с **`display: flex`** или **`grid`**, если родитель имеет значение `z-index`.

2. **Особенности контекста наложения**:
   - **Иерархия контекстов**: Вложенные элементы наследуют контекст наложения родительского элемента. Если элемент создаёт новый контекст наложения, элементы внутри него не могут пересекать границы этого контекста с помощью `z-index`.
   - **Локальная область видимости**: `z-index` элементов может влиять только на другие элементы внутри одного контекста наложения.

Пример контекста наложения:
```html
<div class="parent">
  <div class="child1">Дочерний элемент 1</div>
  <div class="child2">Дочерний элемент 2</div>
</div>
```

```css
.parent {
  position: relative;
  z-index: 10; /* Новый контекст наложения */
}

.child1 {
  position: relative;
  z-index: 5; /* В пределах контекста наложения родителя */
}

.child2 {
  position: relative;
  z-index: 15; /* Будет выше child1 */
}
```

В этом примере контейнер `.parent` создаёт новый контекст наложения, а элементы `.child1` и `.child2` сортируются по оси z внутри этого контекста. Однако даже если добавить другой элемент за пределами `.parent` с более высоким `z-index`, он не пересечёт границы контекста наложения родителя.

Важные моменты:
- Контексты наложения не могут пересекать друг друга. Если два элемента находятся в разных контекстах наложения, их `z-index` сравнивается только внутри этих контекстов.
- Понимание того, как работают контексты наложения, помогает избежать проблем с неожиданным наложением элементов на странице.

Итог:
**`z-index`** управляет порядком наложения элементов по оси z. Контекст наложения создаёт ограниченные области, в пределах которых элементы сортируются. Контексты наложения могут создаваться при различных условиях (позиционирование, `opacity`, `transform` и др.), и элементы внутри этих контекстов не могут влиять на элементы вне их.

##### Источники:

- [MDN](https://developer.mozilla.org/ru/docs/Web/CSS/z-index)
- [CSS Tricks: Понимание контекста наложения](https://css-tricks.com/almanac/properties/z/z-index/)
- [Дока](https://doka.guide/css/stacking-context/)

---



#### 10. Опишите контекст блочного форматирования (Block Formatting Context, BFC) и как он работает.

**Ответ:**

**Block Formatting Context (BFC)** — это изолированная область на веб-странице, в которой элементы расположены по определённым правилам блочного форматирования. Это важный концепт в CSS, который помогает управлять поведением блоков, например, при работе с плавающими элементами или отступами.

Как работает BFC:

Когда элемент становится частью контекста блочного форматирования (BFC), он создаёт независимую область, в которой его дочерние элементы форматируются по собственным правилам. Внутри BFC происходит следующее:
- Элементы располагаются вертикально, один за другим, начиная с верхней границы контейнера.
- Вертикальные отступы (margins) соседних блоков могут схлопываться, но внутри BFC это схлопывание не происходит.
- Плавающие элементы (`float`) внутри BFC учитываются при расчёте размера блока, а не выходят за его границы.
- BFC предотвращает наложение содержимого блока на плавающие элементы.

Как создаётся BFC:

BFC создаётся в следующих случаях:
1. Элемент имеет свойство `overflow`, установленное в одно из значений, отличных от `visible` (например, `hidden`, `auto` или `scroll`).
2. Элемент имеет значение `float`, отличное от `none`.
3. Элемент имеет значение `display: inline-block`, `display: table-cell`, `display: table-caption` или `display: flex/grid`.
4. Элемент имеет свойство `position` со значениями `absolute` или `fixed`.

Пример BFC:

```html
<div class="container">
  <div class="box1">Первый блок</div>
  <div class="box2">Второй блок</div>
</div>
```

```css
.container {
  overflow: hidden; /* Создание BFC */
}

.box1 {
  float: left;
  width: 100px;
  height: 100px;
  background-color: lightblue;
}

.box2 {
  background-color: lightgreen;
  margin-top: 20px;
}
```

Как это работает:
1. В примере выше контейнер `.container` создаёт BFC благодаря свойству `overflow: hidden`. Это гарантирует, что элемент `.box2`, даже если `.box1` плавает слева (`float: left`), не пересекает его границы.
2. Также, поскольку BFC изолирует элементы внутри себя, вертикальные отступы между элементами `.box1` и `.box2` не будут схлопываться.

Применение BFC:

- **Управление плавающими элементами**: BFC полезен, когда нужно контролировать, как другие элементы обтекают плавающие элементы. Если элемент внутри BFC, то он не будет пересекаться с плавающими элементами.
- **Предотвращение схлопывания отступов**: BFC может помочь избежать схлопывания вертикальных отступов между элементами.
- **Контроль над переполнением содержимого**: Если элемент создаёт BFC с помощью `overflow`, это гарантирует, что переполняющий контент будет обрезан или прокручиваться.

Важные моменты:
- Элементы внутри одного BFC не взаимодействуют по правилам блочного форматирования с элементами вне этого BFC.
- Создание BFC — это способ изолировать элементы и контролировать их взаимодействие с соседними блоками.

Итог:
**Block Formatting Context (BFC)** — это изолированная область, в которой элементы форматируются по определённым правилам. BFC полезен для работы с плавающими элементами, предотвращения схлопывания отступов и управления переполнением контента.

##### Источники:

1. [MDN: Block formatting context (BFC)](https://developer.mozilla.org/ru/docs/Web/Guide/CSS/Block_formatting_context)
2. [CSS Tricks: What You Should Know About BFC](https://css-tricks.com/what-you-should-know-about-bfc/)
3. [Smashing Magazine](https://www.smashingmagazine.com/2017/12/understanding-css-layout-block-formatting-context/)

---

#### 11. Какие существуют различные техники очистки (clearing) и в каких ситуациях они наиболее уместны?

**Ответ:**

В CSS **очистка (clearing)** — это процесс, который предотвращает "обтекание" плавающих элементов другими элементами. Очистка важна, когда плавающие элементы выводятся из нормального потока, что может привести к тому, что родительский контейнер не будет учитывать их высоту, а соседние элементы будут располагаться неправильно.

Основные техники очистки:

1. **Использование свойства `clear`**:
   - Свойство `clear` применяется к элементу, чтобы он располагался ниже плавающих элементов.
   - Значения:
     - `left`: Очищает обтекание элементов, плавающих слева.
     - `right`: Очищает обтекание элементов, плавающих справа.
     - `both`: Очищает обтекание для элементов, плавающих как слева, так и справа.

   Пример:
   ```html
   <div class="float-element">Плавающий элемент</div>
   <div class="clear-element" style="clear: both;">Элемент с очисткой</div>
   ```

   **Когда использовать**: Техника `clear` подходит для простых случаев, когда нужно убедиться, что последующий контент не обтекает плавающий элемент.

2. **Техника "clearfix" (с использованием псевдоэлемента `::after`)**:
   - Эта техника добавляет псевдоэлемент после плавающих элементов внутри родительского контейнера, который автоматически очищает обтекание.
   
   Пример:
   ```css
   .clearfix::after {
     content: "";
     display: table;
     clear: both;
   }
   ```

   Применение:
   ```html
   <div class="clearfix">
     <div class="float-left">Левый плавающий элемент</div>
     <div class="float-right">Правый плавающий элемент</div>
   </div>
   ```

   **Когда использовать**: Эта техника полезна, когда нужно очистить обтекание внутри родительского контейнера, чтобы он корректно учитывал высоту плавающих элементов. Она предпочтительна для макетов с несколькими плавающими элементами, где необходимо контролировать высоту контейнера.

3. **Использование свойства `overflow`**:
   - Установка свойства `overflow` в значения, отличные от `visible` (например, `hidden`, `auto`, `scroll`), также создаёт контекст блочного форматирования (BFC), который может автоматически очистить обтекание плавающих элементов.
   
   Пример:
   ```css
   .container {
     overflow: hidden; /* Очищает обтекание */
   }
   ```

   Пример HTML:
   ```html
   <div class="container">
     <div class="float-left">Левый плавающий элемент</div>
     <div class="float-right">Правый плавающий элемент</div>
   </div>
   ```

   **Когда использовать**: Использование свойства `overflow` подходит в тех случаях, когда нужно быстро очистить обтекание без добавления дополнительных элементов или сложных стилей. Это также полезно, если вам нужно управлять переполнением содержимого внутри контейнера.

Сравнение техник:

- **`clear: both`** — Прямолинейный метод, удобный для отдельных элементов. Однако требует добавления дополнительных элементов с очисткой.
- **"clearfix"** — Более универсальный и популярный метод. Он чисто реализован через CSS и часто используется для макетов с несколькими плавающими элементами, избегая добавления лишних элементов в HTML.
- **`overflow: hidden`** — Быстрый и простой способ, но не всегда подходит, если внутри контейнера должно быть содержимое с прокруткой или если нужно обработать переполнение.

Итог:
Существует несколько техник очистки обтекания: использование свойства `clear`, техника "clearfix" с псевдоэлементом `::after` и использование свойства `overflow`. Каждая из них подходит для разных сценариев, и выбор техники зависит от того, насколько сложен макет и нужно ли учитывать переполнение контейнера.

##### Источники:
- [MDN: Свойство clear](https://developer.mozilla.org/ru/docs/Web/CSS/clear)
- [CSS Tricks: The clearfix hack](https://css-tricks.com/snippets/css/clear-fix/)

---