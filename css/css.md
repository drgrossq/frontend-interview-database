#### 1. Свойство display - основные значения и как они работают.


Свойство `display` меняет стандартный тип отображения на произвольный. `display` принимает множество значений, но основные - это: 
- `none` - полностью скрывает элемент со страницы, не удаляя его при этом из HTML-разметки
- `block` - размер определяется размером самого блока заданными в стилях, но сам блок занимает всю свободную ширину экрана
- `inline` - элементы расположены в одну строку и их размер зависит от содержимого
- `inline-block` - элементы расположены в одну строку, но элементам можно задавать размеры
- `flex` - элемент становится флекс-контейнером, ведёт себя как блочный, а вложенные элементы становятся флекс-элементами
- `grid` - элемент становится грид-контейнером. Снаружи грид-контейнер ведёт себя как блок. Дочерние элементы такого контейнера начинают подчиняться правилам грид-раскладки


##### Источники:

- [Спецификация](https://www.w3.org/TR/css-display-3/)
- [Дока](https://doka.guide/css/display/)
- [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/display)

---

#### 2. @keyframes - для чего нужно и как использовать?


Директива `@keyframes` используется для создания _ключевых кадров_ CSS-анимаций. После ключевого слова `@keyframes` мы должны написать имя анимации. Оно понадобится нам, чтобы связать анимацию для конкретного элемента с ключевыми кадрами. Ключевые кадры могут прописываться при помощи ключевых слов from (начальный кадр) и to (конечный кадр). Если же кадров больше двух, то можно использовать проценты. Пример:

```CSS
div {
  animation: diagonal-slide 1s infinite;
}

@keyframes diagonal-slide {

  from {
    left: 0;
    top: 0;
  }

  to {
    left: 100px;
    top: 100px;
  }

}
```

##### Источники:

- [Спецификация](https://www.w3.org/TR/css-animations-1/#keyframes)
- [Дока](https://doka.guide/css/keyframes/)
- [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes)

---

#### 3. Что делает box-sizing: border-box?

Свойство `box-sizing` определяет как вычисляется общая ширина и высота элемента. По умолчанию размером элемента считается размер контентной области. Если кроме `width` и `height` указать ещё и `padding` с `border`, то браузер посчитает размер элемента как `width + padding * 2 + border * 2 и height + padding * 2 + border * 2`. Если задать значение `border-box` для свойства `box-sizing`, то браузер изменит принцип расчёта и `padding` с `border` уже будут включены в `width` и `height`.

##### Источники:

- [Спецификация](https://www.w3.org/TR/css-sizing-3/#box-sizing)
- [Дока](https://doka.guide/css/box-sizing/)
- [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing)

---

#### 4. Разница между margin и padding?

`margin` - задаёт размер внешнего отступа вокруг элемента. Верхний и нижний отступы не работают для элементов `<span>`, `<code>` и других строчных элементов. Выход в данной ситуации — сделать строчные элементы строчно-блочными (`inline-block`) или блочными (`block`).
`padding` - устанавливает внутренние отступы со всех сторон элемента. Область отступов это пространство между содержанием элемента и его границей. Отрицательные значения не допускаются.

![CSS Box Model](../img/CSS%20Box%20Model.png)

##### Источники:

- [Спецификация по margin](https://drafts.csswg.org/css-box/#margins)
- [Спецификация по padding](https://drafts.csswg.org/css-box/#paddings)
- [Дока по margin](https://doka.guide/css/margin/)
- [Дока по padding](https://doka.guide/css/padding/)
- [MDN по margin](https://developer.mozilla.org/en-US/docs/Web/CSS/margin)
- [MDN по padding](https://developer.mozilla.org/en-US/docs/Web/CSS/padding)

---

#### 5. Чем border отличается от outline?

`outline` - это линия за пределами рамки элемента и в отличии от `border` не влияет на размеры элемента т.к. `outline` не является частью блочной модели CSS. 

##### Источники:

- [Спецификация по border](https://www.w3.org/TR/css-backgrounds-3/#propdef-border)
- [Спецификация по outline](https://www.w3.org/TR/css-ui-4/#outline-props)
- [Дока по border](https://doka.guide/css/border/)
- [Дока по outline](https://doka.guide/css/outline/)
- [MDN по border](https://developer.mozilla.org/en-US/docs/Web/CSS/border)
- [MDN по outline](https://developer.mozilla.org/en-US/docs/Web/CSS/outline)

---

#### 6. Что такое специфичность селекторов CSS и как она работает?

**Ответ:**

**Специфичность селекторов CSS** — это механизм, который браузер использует для определения приоритета различных CSS-правил, применяемых к одному и тому же элементу. Специфичность вычисляется на основе типа селекторов, используемых в CSS-правилах, и помогает решить, какое из конфликтующих правил должно быть применено.

Как работает специфичность:

Специфичность выражается в виде числового значения, которое состоит из четырёх частей (обычно представляется как "четырёхзначное число"). Каждому типу селектора присваивается определённый вес:

1. **Inline-стили** (применяемые через атрибут `style` в HTML) имеют наибольший вес. Например:
   ```html
   <div style="color: red;"></div>
   ```
   Этот стиль имеет самую высокую специфичность и будет всегда иметь приоритет перед внешними стилями.

2. **ID-селекторы** (`#id`) имеют высокую специфичность. Пример:
   ```css
   #myId {
     color: blue;
   }
   ```

3. **Классы** (`.class`), атрибуты (`[type="text"]`) и псевдоклассы (`:hover`, `:nth-child`) имеют меньшую специфичность, чем ID-селекторы. Пример:
   ```css
   .myClass {
     color: green;
   }
   ```

4. **Теговые селекторы** (`div`, `p`, `h1` и т.д.) и псевдоэлементы (`::before`, `::after`) имеют самую низкую специфичность. Пример:
   ```css
   div {
     color: black;
   }
   ```

Пример работы специфичности:

```html
<div id="example" class="box"></div>
```

```css
div {
  color: black; /* Специфичность: 0,0,0,1 */
}

.box {
  color: green; /* Специфичность: 0,0,1,0 */
}

#example {
  color: blue; /* Специфичность: 0,1,0,0 */
}
```

В этом примере браузер выберет **синий цвет** для текста элемента, так как селектор `#example` имеет самую высокую специфичность (0,1,0,0). Правило с селектором класса `.box` имеет меньшую специфичность (0,0,1,0), а правило для тега `div` — самую низкую (0,0,0,1).

Способ вычисления специфичности:

- **Inline-стили**: 1,0,0,0
- **ID-селекторы**: 0,1,0,0
- **Классы, атрибуты, псевдоклассы**: 0,0,1,0
- **Теги и псевдоэлементы**: 0,0,0,1

Важные моменты:
- **`!important`**: Этот флаг всегда имеет приоритет над другими правилами, но он не отменяет inline-стили с `!important`.
- Если два правила имеют одинаковую специфичность, применяется то, которое определено последним в CSS-файле.

Итог:
**Специфичность селекторов CSS** — это числовое выражение, определяющее приоритет стилей. Чем выше специфичность селектора, тем больше вероятность, что его стили будут применены к элементу.

##### Источники: 

- [MDN](https://developer.mozilla.org/ru/docs/Web/CSS/Specificity).

---

#### 7. В чём разница между "сбросом" (resetting) и "нормализацией" (normalizing) CSS? Что бы вы выбрали и почему?

**Ответ:**

Разница между "сбросом" (resetting) и "нормализацией" (normalizing) CSS заключается в их подходе к устранению различий в стилях между браузерами.

1. **Сброс (resetting) CSS**:
   - CSS-сброс предполагает **удаление всех встроенных стилей** браузера. Это делает все элементы на странице полностью унифицированными по стилю и лишёнными дефолтного форматирования, которое браузеры применяют по умолчанию (например, отступы у списков, размер шрифтов заголовков и т.д.).
   - Один из самых известных примеров — это CSS-файл от **Eric Meyer**:
     ```css
     /* Пример сброса CSS */
     html, body, div, span, applet, object, iframe,
     h1, h2, h3, h4, h5, h6, p, blockquote, pre,
     a, abbr, acronym, address, big, cite, code,
     del, dfn, em, img, ins, kbd, q, s, samp,
     small, strike, strong, sub, sup, tt, var,
     b, u, i, center,
     dl, dt, dd, ol, ul, li,
     fieldset, form, label, legend,
     table, caption, tbody, tfoot, thead, tr, th, td,
     article, aside, canvas, details, embed,
     figure, figcaption, footer, header, hgroup,
     menu, nav, output, ruby, section, summary,
     time, mark, audio, video {
       margin: 0;
       padding: 0;
       border: 0;
       font-size: 100%;
       font: inherit;
       vertical-align: baseline;
     }
     ```

   - Основная цель сброса CSS — сделать все элементы "чистыми", чтобы начать стилизацию с нуля.

2. **Нормализация (normalizing) CSS**:
   - Нормализация CSS не сбрасывает все стили до нуля, а вместо этого **делает дефолтные стили браузеров более согласованными**. Она сохраняет полезные стили (например, отступы у заголовков, шрифты у параграфов), но устраняет кроссбраузерные несоответствия.
   - Пример: **Normalize.css** — это популярная библиотека для нормализации.
     ```css
     /* Пример нормализации CSS */
     html {
       line-height: 1.15; /* Исправляет баг размера шрифта в некоторых браузерах */
       -webkit-text-size-adjust: 100%; /* Избегает автонастройки текста в мобильных браузерах */
     }

     body {
       margin: 0; /* Удаляет дефолтные отступы у body */
     }
     ```

   - Цель нормализации — **сохранить полезные стили** и устранить только несовместимости между браузерами.

Что выбрать и почему?

- **Выбор зависит от контекста проекта**.
   - **Сброс CSS** стоит выбрать, если вы хотите **абсолютный контроль** над стилями на странице и вам нужно минимизировать влияние встроенных браузерных стилей. Это полезно для проектов с полным кастомным дизайном, где каждый элемент будет стилизован вручную.
   - **Нормализация CSS** предпочтительна, если вы хотите **сохранить полезные стандартные стили**, но при этом устранить кроссбраузерные баги. Это хороший выбор для большинства проектов, поскольку он не требует начинать стилизацию с нуля и помогает избежать ненужной работы по восстановлению полезных дефолтных стилей.

##### Источники: 

- [Normalize.css](https://necolas.github.io/normalize.css/)

---
